% LaTeX mintafájl szakdolgozat és diplomamunkáknak az
% SZTE Informatikai Tanszekcsoportja által megkövetelt
% formai követelményeinek megvalósításához
% Modositva: 2011.04.28 Nemeth L. Zoltan
% A fájl használatához szükséges a magyar.ldf 2005/05/12 v1.5-ös vagy késõbbi verziója
% ez letölthetõ a http://www.math.bme.hu/latex/ weblapról, a magyar nyelvû szedéshez
% Hasznos információk, linekek, LaTeX leirasok a www.latex.lap.hu weboldalon vannak.
%


\documentclass[12pt]{report}

\linespread{1.3}

%Magyar nyelvi támogatás (Babel 3.7 vagy késõbbi kell!)
\def\magyarOptions{defaults=hu-min}
\usepackage[magyar]{babel}

%Az ékezetes betûk használatához:
\usepackage{t1enc}% ékezetes szavak automatikus elválasztásához
\usepackage[latin2]{inputenc}% ékezetes szavak beviteléhez

% A formai kovetelmenyekben megkövetelt Times betûtípus hasznalata:
\usepackage{times}

%Az AMS csomagjai
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}

%A fejléc láblécek kialakításához:
\usepackage{fancyhdr}

%Természetesen további csomagok is használhatók,
%például ábrák beillesztéséhez a graphix és a psfrag,
%ha nincs rájuk szükség természetesen kihagyhatók.
\usepackage{graphicx}
\usepackage{psfrag}

%Tételszerû környezetek definiálhatók, ezek most fejezetenkent egyutt szamozodnak, pl.
\newtheorem{tét}{Tétel}[chapter]
\newtheorem{defi}[tét]{Definíció}
\newtheorem{lemma}[tét]{Lemma}
\newtheorem{áll}[tét]{Állítás}
\newtheorem{köv}[tét]{Következmény}

%Ha a megjegyzések és a példak szövegét nem akarjuk dõlten szedni, akkor
%az alábbi parancs után kell õket definiální:
\theoremstyle{definition}
\newtheorem{megj}[tét]{Megjegyzés}
\newtheorem{pld}[tét]{Példa}

%Margók:
\hoffset -1in
\voffset -1in
\oddsidemargin 35mm
\textwidth 150mm
\topmargin 15mm
\headheight 10mm
\headsep 5mm
\textheight 237mm


\graphicspath{ {img/} }

\begin{document}

%A FEJEZETEK KEZDÕOLDALAINAK FEJ ES LÁBLÉCE:
%a plain oldalstílust kell átdefiniálni, hogy ott ne legyen fejléc:
\fancypagestyle{plain}{%
%ez mindent töröl:
\fancyhf{}
% a láblécbe jobboldalra kerüljön az oldalszám:
\fancyfoot[R]{\thepage}
%elválasztó vonal sem kell:
\renewcommand{\headrulewidth}{0pt}
}

%A TÖBBI OLDAL FEJ ÉS LÁBLÉCE:
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{Development and automated testing in Firefox OS environment}
\fancyfoot[R]{\thepage}


%A címoldalra se fej- se lábléc nem kell:
\thispagestyle{empty}

\begin{center}
\vspace*{1cm}
{\Large\bf Szegedi Tudományegyetem}

\vspace{0.5cm}

{\Large\bf Informatikai Tanszékcsoport}

\vspace*{3.8cm}


{\LARGE\bf Development and automated testing in Firefox OS environment }


\vspace*{3.6cm}

{\Large Szakdolgozat}

\vspace*{4cm}

%Értelemszerûen megváltoztatandó:
{\large
\begin{tabular}{c@{\hspace{4cm}}c}
\emph{Készítette:}     &\emph{Témavezetõ:}\\
\bf{Sánta Gergely}  &\bf{Lengyel Zsolt}\\
gazdaságinformatikus szakos     &\\
hallgató&
\end{tabular}
}

\vspace*{2.3cm}

{\Large
Szeged
\\
\vspace{2mm}
2014
}
\end{center}


%A tartalomjegyzék:
\tableofcontents

%A \chapter* parancs nem ad a fejezetnek sorszámot
\chapter*{Feladatkiírás}

The goal of the thesis is to design an effective development methodology for Firefox OS, with great emphasis on the automated testing and debugging tasks and opportunities occuring at various stages of the development. During the selection of the various tools preference should be given to already proven and mature web development technologies (since this is the main goal of Firefox OS), nonetheless the specific requirements and toolkit of the new platform should also be presented. The previously described items should be utilized with an example application besides the theoretical implementation. 



%A tartalomjegyzékben mégis szerepeltetni kell, mint szakasz(section) szerepeljen:
\addcontentsline{toc}{section}{Feladatkiírás}
\chapter*{Tartalmi összefoglaló}


\addcontentsline{toc}{section}{Tartalmi összefoglaló}

\chapter*{Introduction}
\addcontentsline{toc}{section}{Introduction}

Firefox OS is one of the latest operating systems for mobile phones and tablets. It was released in February 2012 by Mozilla as an open-source project based on a Linux kernel code named as boot to gecko (B2G). 

One important concept behind Firefox OS is to provide full smartphone experience at an affordable price targeting primarily the developing countries. In many of them Firefox OS is already present (including Hungary),  and the expansion continues this year, with more device manufacturer (inclding ZTE) shipping their mobile phones with Firefox OS besides android. 

The other major idea of the OS is the broad development community it intends to target. It uses open tools used throughout the web like javascript and HTML5, enabling the use of millions of already existing web application with little or no modification. More and more companies needs to be present on the mobile app market in addition to the web, spending an increasing amount of mony for application development to support the various mobile platforms. There is an emerging new era of mobile app development, due to the sophisticated mobile browsers of today, where it is possible to use full screen sized web applications, which look and work almost like a native app. These modern browsers have built in support for native APIs such as camera and GPS. Firefox OS successfully sensed this new trend making the environment of the web as their native environment. It is even possible to install apps from the Firefox OS marketplace in desktop or android environmentis, that work similarly as native applications.  

However the many advantages of the platform does not make it automatically a market success. With the release of 2.2 there are still performance issues and unexpected system crashes, that can ruin the platforms reputation, since in some countries it is already available for production. The other problem is the lack of applications in the Firefox OS marketplace. Despite the relative ease of app development for this paltform, and the huge community of potential developers, it is hard to make the software vendors port their apps, without a significant market share. 

In my thesis I focus on the development and testing of Firefox OS application. The motive behind this is to contribute to the development of this promising platform by collecting the best of the tools and practices, the potential developers need. Most of these tools are already widely used in other areas of software engineering (mainly in web development), but the lack of documentation, experience, tutorials and other resources make it difficult for the developers to utilize their existing experience. Some other tools are were created specifically to suppport development for the Firefox OS platform. These tools are very young and change quickly so I try to empahsize the general idea behind them rather than the exact usage of each one. One of the biggest and most important part of my thesis will explore and explain the process of automated testing, which can help to produce and maintain high quality applications.  

Throughout my thesis I demonstrate the concepts and tools through a real app I develped. This is a bycicle application, where the bycicle routes are created and maintained by the community. The users adds the routes' points to the map, and 
other users can rate these, so that to be able to maintain a high quality route system. The application is by no means production quality, but good enough for demonstration purposes and to bring the concepts closer to the user.

My goal was to make my research more digestible for anyone interested in this topic. Every chapter starts with a theoretical part where I iterate over the possible solutions for the given subject and try to chose the most appropriate one based on usability, popularity, and other characteristics of the actual situation. After that I dig into the chosen tool more deeply to get the reader more familiar with it, and to show how this tool can solve the present problem. At the end of the chapter I guide the reader through a concrete use case with the help of the application I developed.  

\chapter{Introduction to Firefox OS}

\section{The Firefox OS ecosystem}

Firefox OS is an open source operating system aiming mobile and tablet devices. 
It is based on a Linux kernel and oficially named as Boot to Gecko (B2G). The main idea behind Fireox OS is to embrace the ever expanding ecosystem of the open web, and to enable the use of these tools throughout the whole application development process. One of the hottest topics of the web today is HTML5, which encompasses open web standards like HTML, CSS and Javascript. Firefox OS is built with these in mind, by developing Web APIs so that HTML5 applications can communicate with the device's hardver. It works like a web browser running on a lightweight Linux kernel, where every application is a standalone web app, even the native ones like the Camera or the Phone.

The User Interface of Firefox OS looks a lot like Android, with a lock screen, home screen and notification area. The deletion and closing of application works also similarly. However as it is getting more mature, it's own characteristics have started to appear. For example it does not use the paging structure of android for the apps, but rather a vertical scrollbar similar to the solution of modern web applications for handling it's contents. This infinite scrolling style does not olny charachterize the home screen, but it is utilized by also the applications, making the look and feel smooth and consistent throuthout the different views of the phone. 

The platform differentiates two kinds of applications. Both of them are distributed through the Firefox Marketplace. Hosted apps resides on a server and work similar to traditional web pages. The only difference is the app manifest in the app's root directory, which provides important details about the app, such as the path of the main html file and the name of the application. This information is needed to be able to install the application with a native-like procedure. There are some security constraints concerning hosted apps that does not enable them to use privileged and certified APIs. If an app needs greater controll over the phones resources, it should be distributed as a packaged app. A packaged app containes all of its resources in a zip file, with the app manifast at the root directory. Packaged apps can be further divided into three categories: web app, privileged app and certified app, going from the most restrictive one to the digitally signed categories, that enable the use of priviledged and certified APIs. Privileged apps are signed as part of the Marketplace review process, while certified apps are signed by device manufacturers. Packaged apps tend to open up more quickly than hosted apps, because all of their resources are stored locally, making the user experience more smooth.    

Considering the applications, the Firefox OS ecosystem does not stay within the limits of devices running Firefox OS. The notions of Open Web Apps for Android and Open Web Apps for Desktop enable Marketplace apps to be installed into Android and Windows respectively. These are executed by Web Runtime, a compontent of the given platform's Firefox based browser.

\section{The architecture of Firefox OS}

This section reveals how Firefox OS builds up, from bottom to top, explaining each layer more deeply, because an application developer's main concerns connect to layers in higher levels, where the app interacts with the system.

The lowest level operating system, named Gonk, encompasses the Linux kernel and other hardware related layers. It is a porting target of Gecko, which means, there is a port of Gecko to Gonk, just like there is a port of Gecko to Android or Windows. One difference is that Gonk is part of the Firefox OS project, so it is more lenient when it comes to Gecko, exposing direct access to the full telephony stack and display frame buffer.

The next layer is the application runtime, named Gecko. It is actually the web browser engine used in many applications developed by Mozilla. It supports open web standards like HTML, CSS, and Javascript, and makes sure those APIs work well on every operating system it supports. Gecko includes, among other things, a networking stack, graphics stack and a Javascript virtual machine.

At the top of the hierarchy resides the application layer, that contains the various kinds of apps, javascript libraries and Gaia. Gaia, written entirely in HTML, CSS and Javascript, is the platform's user interface and contains all the system and certified apps. It communicates with the underlying operating system through standard Web APIs, implemented by Gecko. The separation of Gaia from the system specific components enables it to run on other operating systems and web browsers, widening the potential market Firefox OS apps can reach. More information about how Gaia handles and stuctures apps can be found in the next section. 

\begin{figure}[h]
\centering
\includegraphics{firefox_os_arch.eps}
\caption{The architecture of Firefox OS}
\end{figure}

\subsection{How Gaia handles custom apps}

To imitate the behaviour of desktop browsers, where webpages live in different windows or tabs, Firefox OS opens each app in a new iframe. It has a lot of security adventages because it sandboxes the apps. This means each app has access onlty to it's own resources (cookies, IndexedDB, etc.). A practical example can be the case when the user logs in to Facebook in App A, which has no effect on App B's ability to interact with the user's account on Facebook. The next code snippet shows a typical iframe, Firefox OS sandboxes each app into.

\begin{verbatim}
<iframe id="browser2" mozallowfullscreen="true" mozbrowser="true"
 src="", data-url="" data-frame-type="window" data-frame-origin="...">
</iframe>
\end{verbatim} 


\section{Development tools for Firefox OS}

There are multiple possibilities for developers to try their Firefox OS apps during development.

\subsection{Firefox OS Simulator}

 The simplest solution is the Firefox OS simulator developed by Mozilla and available as an add-on in the desktop browser. It simulates the higher layers of Firefox OS, and makes it easy for developers to test and verify their apps behaviour quickly, without a device. It runs in a window the same size as a Firefox OS device, includes the Firefox OS user interface and built-in apps, and simulates many of the Firefox OS device APIs. 

After installing one of the simulator add-ons (there are multiple simulators corresponding to the version of Firefox OS), it appears in the Firefox App Manager. The app manager can be opened by typing in the URL bar the following: about:app-manager. At the bottom of the page appears the Start Simulator button, clicking it reveals the installed simulators and gives the option to install other versions of it. Choosing one of them and clicking it opens the simulator in a new window. The apps tab of the App Manager can be used to add packaged or hosted apps to the App Manager, that can be later uploaded to the simulator with the update button of the actual app's window. The debug button does the same, but it also connects a toolbox to the app, allowing to debug its code directly with the usual debugging tools the Firefox browser offers. 

From Firefox 33 onwards Firefox includes a tool called WebIDE, whose purpose is to replace the App Manager. It's functionality is similar to App Manager's, but it also provides an editing environment for developers to create Firefox OS apps. Since the App Manager was more stable at the time of this writing, I use it throughout my thesis instead of the WebIde.

\subsection{Firefox OS desktop build}

The Firefox OS desktop client (B2G desktop cliend) can be used to run Web apps in a Gecko-based environment. It does not emulate device hardware, but can be useful during the development process for quick tests and user interface verification. As I noticed through my research the Desktop Build is the least popular of the possible to run Firefox apps, and mainly used by Gaia developers working on the Gaia user interface. However it has a big advantage over the simulator and the real device: it containes a pre-installed marionette server, that can be used to run user interface tests. This topic is covered deeply at Chapter 3.

Adding a custom app to the desktop build is difficult, because the developer has to package the app's files himself, copy it to the appropriate location and put the app's information to a configuration json file. However from February 2014 it is possible to run a custom B2G binary (a.k.a desktop build) and/or a custom Gaia profile from the simulator, making app uploading easy thorugh the App Manager, or WebIDE. It can be done by typing about:addons to the URL bar. The Extensions tab lists the installed simulator, clicking on the Preferences button of the chosen simulator, it jumps to a page where the path of the custom B2G or Gaia profile can be selected. From then on, when running the simulator it uses the given B2G or Gaia profile instead of the built-in one, enabling to run user interface tests via marionette. I had connection problems to B2G, when trying to run it from the App Manager and WebIDE on my Ubuntu machine, so in Chapter 3, where I describe marionette tests, I do not use this solution and add my app to the desktop build by hand.    
 
\subsection{Running apps on a real device}

The simulator and destop build are good for running quick tests, but they lack some hardware functionlity, that makes it necessarry for developers to try their apps from time to time on a real device. Fortunately it is very easy to do. On the device Remote debugging has to be checked, which is located in Device Information > More Information > Developer. The device communicates with the computer through the Android Debug Bridge, which means on Ubuntu the ADB Helper add-on needs to be installed. From then on the attached device appears beside the Start Simulator button in App Manager or WebIDE, and can be used the same way as the simulator.

Marionette is available in all Firefox OS builds, but manufacturers disable it in their image files. To run user interface tests in the same way when using a desktop build, the user has to build Firefox OS himself. It is not an easy process, and I will describe it briefly in chapter 3, where I iterate through the options of running automated tests.

\subsection{Example of uploading and running the Travely app}

Now I show through the example app the steps needed to convert a custom web app to become a Firefox app, and how to upload it to the simulator. As previously mentioned, each Firefox app has to have a configuration file, called manifest.webapp. It can contain a lot of information about the app, but only three are mandatory: name, description and icons. In addition to these I added the field launch path which sets the path of the starting html page of the app, and the developer field to clafify, who the application belongs to.
\begin{verbatim}
{
  "name": "Travely",
  "description": "On The Ride",
  "launch_path": "/index.html",
  "icons": {
    "128": "/img/icon.jpg"
  },
  "developer": {
    "name": "Gergely Santa"
  }
}
\end{verbatim}
The manifest.webapp needs to be placed in the root folder of the application. When it's done, it can be added to the App Manager as a packaged app. After starting the simulator and hitting the update button on the right side of the App Manager, the app gets uploaded to the simulator. It works the same way, when attaching a real device to the computer. The process to add an app to the desktop build will be demonstrated in chapter 3. 

\begin{figure}[h]
\centering
\includegraphics[scale=0.7]{simulator.eps}
\caption{The travely app inside the simulator}
\end{figure}

\chapter{Creating a build system for task automation}

(elõreláthatólag 3-4 oldal)

\chapter{Debugging tools}

(elõreláthatólag 2-3 oldal)

\chapter{Creating an environment to run automated UI tests}

\section{What is automated UI testing and why to use it?}

The reason behind automated UI testing is the same as the reason behind unit testing: verifying that the development process does not cause any unexpected behavioural changes. The difference between the two is that while unit testing verifies small pieces of code, executing tests in isolation, UI testing functions at a higher level with the purpose of demonstrating, that different pices of the system work together. In an other perspective unit tests prove that the app works correctily in theory, UI tests verify that in different concrete environments the correctness still stands. This latter approach is very important in a rapidly changing mobile environment, with many different versions, screen sizes and performance characteristics in production. There needs to be a tool, that imitates the actions of the users, makes notifications of potential problems and does it automatically in multiple environments, possibly in parallel. That is exactly what automated UI tests are for, and this chapter gives detailed information about how to do it in the Firefox OS environment.

\section{How automated UI testing works in Firefox OS}

The automation tool for running UI tests in Firefox OS is called Marionette. It can remotely drive either the UI or the internal Javascript of a program built on the Gecko platform, such as Firefox or Firefox OS. Marionette can be divided into two parts: the server runs on the test machine (for example on a Firefox OS device), allowing the user to connect to that server and remotely drive tests and send commands to it. It works similarly how Selenium works in the browser environment. The other part is the marionette client, that runs on the machine the device is attached to, and can connect to the marionette server on that device.

\begin{figure}[h]
\centering
\includegraphics[scale=0.7]{marionette-basic-diagram.eps}
\caption{How marionette server and client interacts}
\end{figure}

The developer interacts olny with the client, so it needs a little more explanation. It is a Python package, so python needs to be set up on the development machine to be able to use it. Pip also has to be installed, that is used to install Python tools, in this case the marionette client. When both python and pip are set up, the following command installs marionette:

\begin{verbatim}
pip install marionette_client
\end{verbatim}

To verify that marionette is successfully installed enter the python console and import the marionette package:

\begin{verbatim}
$python
>>> from marionette import Marionette
\end{verbatim}

Before jumping to write UI tests, the next section describes the options the user has to get a device with an integrated marionette server. 

\section{Options to get a marionette-enabled device}

There are two possibilities to run marionette tests against some Firefox OS environment. One is to use a real device, which of course gives the most realistic environment, and can precisely simulate the actions of the user. Every Firefox OS device is shipped with a built-in marionette server, however the manufacturers disable it by default. For this reason the user needs to build Firefox OS himself, that can be a daunting task, and the process can vary from device to device (not even considering the different versions of Firefox OS). The other problem with a real device is the reduced ability to automate the tests. The device has to be attached to the computer, and it is problematic to test multiple devices at the same time, and impossible to run multiple tests in the same device in paralell. Nonetheless it is important to verify the user interface in a device from time to time making it sure, that everything works well in real circumstances. 

Users have an other option to run marionette tests, which raises the automation to a higher level. The tool for this is the B2G desktop build. The obvious advantage of it is that no real device is needed, and the building process is easier than that of a real device. It makes the paralellism of test running also easier, because it is possible to run on the same machine as many B2G desktop build as needed, with possibly different versions of Firefox OS. For these adventages it is recommended to use this tool to run the daily tests, and only testing with a device when major changes take place, or before releasing a new version of the app.

\subsection{Preparing a device to run marionette tests}

As mentioned previously manufacturers disable marionette server by default, so pre-built image files are not sufficiant. The only way to enable marionette is to build B2G from source. The process varies between OS versions, and the device the user wants to build onto, so I only describe here the most important stages of the building process, and the general considerations the user has to make, before building.

First the user has to make sure, he has a compatible device to build onto. A list of compatible devices are listed on developer.mozilla.org. ADB needs to be installed to establish the communication between the targeting phone and the computer. On the phone remote debuggend has to be enabled. To adb devices command can verify that the device connects properly to the computer.

\begin{verbatim}
$adb devices
List of devices attached
74a17088f488	device
\end{verbatim}

If everything went well, the user is ready for cloning the B2G repository from github.

\begin{verbatim}
git clone git://github.com/mozilla-b2g/B2G.git
cd B2G
\end{verbatim}

The next step is to configure the cloned B2G for the actual device.

\begin{verbatim}
./config.sh peak
\end{verbatim}

After the configuration is done the only task left is to build it. The building automatically flashes B2G onto the phone, so the phone needs to be attached to the computer.

\begin{verbatim}
./build.sh
\end{verbatim}

This whole process can take hours to finish, so be patient.
When the build is ready, the phone runs a marionette-enabled Firefox OS. The difference from the OS shipped by the manufacturer can be immediatly seen by the additional apps on the home screen. These apps can be used to test various parts of the OS, but mainly interesting for those developing Gaia itself. 

At this stage everything works as previously, with the exception of the ability to run marionette UI tests. So the developer can attach his phone to the computer and upload his app through the App Manager thus making the app available for testing. For the marionette client to be able to connect to the server on the phone marionette's local port needs to be forwarded to the port on the device.

\begin{verbatim}
$adb forward tcp:2828 tcp:2828
\end{verbatim}

After that the client should be able to connect to the server on the phone. It can be verified with the next commands:

\begin{verbatim}
from marionette import Marionette
marionette = Marionette()
marionette.start_session()
\end{verbatim}

Now the phone is ready to receive UI tests.

\subsection{Preparing a B2G desktop build to run marionette tests}

The B2G desktop is much easier to configure, than the building process for a real device. The latest B2G desktop can be downloaded from Firefox Nightly site. After extracting it to a folder it can be started right away with the b2g script file.

\begin{verbatim}
$cd B2G
$./b2g
\end{verbatim}

It looks the same as the B2G build for a device, with the additonal apps for testing in the home screen. Though the procedure to get a B2G desktop is quite easy, it is more complicated to add a custom app to it. As I mentioned in section "1.3.2. Firefox OS desktop build", the simulator can be configured to run a custom B2G, making the app uploading process easy, this feature is at an early stage yet, and has some bugs, when trying to upload an app to it. So I explain here how to add an app by hand, and through the process I give a deeper insight how Firefox OS stores apps internally.

The apps can be found in the webapps folder of the gaia profile of b2g.

\begin{verbatim}
$cd  gaia/profile/webapps
\end{verbatim}

Each app has a corresponding folder, each folder having a unique name, that represents the actual app. I named my folder as travely, which is sufficient for testing purposes.

\begin{verbatim}
$ls -l
...
drwxrwxrwx 2 gsanta gsanta  4096 Oct 30 23:00 travely
drwxrwxrwx 2 gsanta gsanta  4096 Oct 24 01:47 uitest.gaiamobile.org
...
\end{verbatim}

The folders contain two files: one is named application.zip and containes the apps file structure with the manifest.webapp at the root. In addition the manifest.webapp needs to be stored outside of the zip too.

\begin{verbatim}
$cd travely && ls
application.zip  manifest.webapp
\end{verbatim}

When it is done, the information about the newly added app have to be listed in the webapps.json file. This file is located at the same level as the folders containing the apps, storing information about all the apps.

\begin{verbatim}
$cd .. && ls 
... packaged.marketplace-dev.allizom.org webapps.json ...
\end{verbatim}

Each app has a lot of fields, but only some of them are interesting right now. It is a good practice to copy the fields of a built-in app, and overwrite the necessary fields. The folder name has to be replaced to the newly app's folder name, it needs a unique localId, and the appStatus has to be changed from 3 to 1. These are obvious changes, only the last one can be confusing. The appStatus signals what kind of app it is, for example certified apps have an appStatus of 3. The reason it is important to change it to 1, because there are much more serious security restrictions applied to certified apps. When I first added the travely app to B2G desktop, I forgot to change it, and some of my js libraries failed to work (for example angularjs), and the error messages I got were very misleading so it was difficult to find what caused the problem. 
So after changing the fields, the relevant parts in webapp.json for the travely app looks like this:

\begin{verbatim}
"travely": {
    ...
    "origin": "app://travely",
    "installOrigin": "app://travely",
    "manifestURL": "app://travely/manifest.webapp",
    "localId": 73,
    "appStatus": 1,
    "id": "travely",
    "basePath": "/home/gsanta/tools/b2g/gaia/profile/webapps",
    "kind": "packaged",
    "enabled": true
    ... 
},
\end{verbatim}

When all these changes are ready, the custom app is added successfully to B2G. Running B2G the app appears at the bottom of the home screen, and is ready to be tested by marionette.

\section{Writing and running marionette UI tests}

\subsection{Finding a specific app with marionette}

As mentioned in 1.2.1. How Gaia handles custom apps, running applications are sandboxed into their corresponding iframes. While it is good for a lot of reasons (for example security), it makes testing more difficult, because marionette needs to find these iframes and switch to them to be able to communicate with spesific apps.
On the internet can be found some examples, how to write marionette tests for Firefox OS (the best is provided by Mozilla at developer.mozilla.org). They explain the concept quite well, but all of them demonstrates how to test some built in application (for example the Contacts app). The problem is, that while it is easy to find these apps, because they have some well known, and well documented characteristics, it is much more difficult to refer to a custom app, that does not have these pre-defined attributes. For example

\chapter{Summary}

(elõreláthatólag 2-3 oldal)



\end{document}
